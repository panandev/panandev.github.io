<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[元素节点的创建，添加，替换与删除。]]></title>
    <url>%2F2017%2F09%2F19%2FDOM03%2F</url>
    <content type="text"><![CDATA[节点的创建与添加 createElement() 创建元素节点用此方法语法格式：document.createElement(&quot;tagName&quot;);例如：document.createElement(&quot;div&quot;); 这样就创建了一个div元素，注意不需要写结尾和尖括号。 createTextNode()，创建文本节点。 语法格式：createTextNode(&quot;PHP学院&quot;); createDocumentFragment()，创建一个临时元素容器(也叫文档片段) 语法格式：var box = document.createDocumentFragment() 该方法返回一个元素容器，用于临时保存新创建的元素，以提高DOM操作的性能。以上是节点创建常用的方法，以下是添加创建的节点常用的方法 appendChild(node)，将node节点添加父元素的末尾 insertBefore(newNode,refNode)，在父元素的参考节点refNode之前插入newNode节点 replaceChild(newNode,oldNode)，将childNodes中的oldNode节点替换成newNode removeChild(node)，从childNodes中删除node节点代码示例演示每个方法的使用情况12345678910111213141516171819202122232425262728293031323334var oUl = document.getElementById("oUl");//创建元素节点的方法var newLi1 = document.createElement("li"); //创建文本节点的方法var newLi1Txt = document.createTextNode("我是新创建的节点li1中的文本");//把文本节点添加到li中(就是把小的逐级向大的内部添加)newLi1.appendChild(newLi1Txt);//把完整的新li节点添加到UL中oUl.appendChild(newLi1);//上面代码创建的有个问题，li中的文本缺少a标记，改进如下var newLi2 = document.createElement("li"); //创建A元素并设置其属性var newLi2A = document.createElement("a"); newLi2A.href="http://www.baidu.com"; newLi2A.target = "_blank";//创建文本节点var newLi2Txt = document.createTextNode("连接词");//逐级向上级元素的内部添加newLi2A.appendChild(newLi2Txt);newLi2.appendChild(newLi2A); oUl.appendChild(newLi2);var fragment = document.createDocumentFragment();var li = null;for(var i=0;i&lt;1000;i++)&#123; li = document.createElement("li"); li.appendChild(document.createTextNode("通过Fragmeng片段可以减少渲染次数提高性能")); fragment.appendChild(li); // oUl.appendChild(li); //理论上这一句比上一句效率低，但是实际情况是老浏览器基本是这样，新浏览器差不多。&#125;oUl.appendChild(fragment); 提示：使用appendChild与createElement创建添加大量节点实战证明不是很高效。 一般使用innerHTML效率可以有N倍的提升。下一节，节点的替换和删除。 下下一节innerHTML。 节点的替换与删除12345678910111213141516171819var oUl = document.getElementById("oUl");//删除节点oUl.removeChild(oUl.childNodes[0].nextSibling); //原有的LI1，就被删除了//替换节点//创建一个新节点var li = document.createElement("li");var txt = document.createTextNode("我替换了另外一个节点");li.appendChild(txt);//用新节点替换旧节点oUl.replaceChild(li,oUl.childNodes[2]);//在特定节点前插入新节点var h2 = document.createElement("h2");var h2txt = document.createTextNode("我是H2中的内容"); h2.appendChild(h2txt);var box = document.getElementById("box");var h1t = document.getElementById("h1t");box.insertBefore(h2,h1t);]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript DOM 节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[元素节点，属性节点，文本节点及其类型判断和查找]]></title>
    <url>%2F2017%2F09%2F18%2FDOM%E8%8A%82%E7%82%B902%2F</url>
    <content type="text"><![CDATA[元素节点1.元素节点规定元素节点具有以下特点： 1、nodeType 值为1 2、nodeName 值为元素的标签名（还一个别名tagName） 3、nodeValue 值为null 4、parentNode 一般是Element,也可能是Document 5、其子节点可能是 Element、Text、Conment等代码示例：123456789var div1 = document.getElementById("div1");echo(div1.nodeName); //输出：DIV，用途判断节点的名称echo(div1.nodeType); //输出：1，用途判断节点的类型echo(div1.nodeValue); //输出：null，用途获取节点值echo(div1.parentNode); //输出：[object HTMLPreElement]，用途获取父节点echo(div1.parentNode.nodeName); //输出：PRE ，用途获取父节点名称echo(div1.childNodes); //[object NodeList] ，用途获取子节点echo(div1.childNodes.length); //输出：2，查看本节点下面子节点的个数echo(div1.childNodes.item(1).nodeValue); //输出：第二节点 属性节点属性节点常用方法与通用属性HTML每个元素都包含下列常用属性 1、id：元素在文档中的唯一标识符 2、title：元素细节的附加说明信息，一般鼠标放上去时候以提示形式显示。 3、className：与CSS特性对应。除了以上通用属性外，部分元素还有自己特有的属性。12345678910var aid = document.getElementById("aid");// //获取属性信息：getAttributeecho(aid.getAttribute("href")); //输出：phpdl.comecho(aid.getAttribute("title")); //超级链接Title //设置属性信息：setAttribute()aid.setAttribute("title","我是动态TITLE"); //添加属性节点//删除属性信息：removeAttribute()aid.removeAttribute("href");//批量使用属性信息echo(aid.attributes.length); //返回一个元素的属性个数 获取元素的常用属性123456var objH = document.getElementById("objh");echo(objH.id); //输出：objhecho(objH.nodeName); //输出：h1echo(objH.className); //输出：borderclsecho(objH.align); //输出：centerobjH.className = "bordercls bgcls"; //设置元素的CSS样式 说明：元素对象.属性 可以快速访问和设置，是最常用的形式，但不是所有的都能通过这种方法得到我们想要的结果 例如：aid.href不一定能获取超连接href的值 123var obj1 = document.getElementById("Dh1");var obj2 = document.getElementById("Dh2");alert(obj1.innerText + obj2.textContent); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/封装写函数function echo( str, flag )&#123; if(arguments[1]==1)&#123; document.write(arguments[0]); &#125; else&#123; document.writeln(arguments[0]); &#125; &#125; ``` ## 文本节点文本节点由Text类型表示，包含的是可以按照字面解释的纯文本内容。 可以是转义后的HTML字符，但是不能包含HTML代码。 文本节点有以下特征： 1. nodeType 值为3 2. nodeName 值为 “#text” 3. nodeValue 值为节点所包含的文本(别名：data属性) 4. parentNode 是一个Element 5. 不能包含子节点，文本节点是最小单元。 虽然文本节点不能包含子节点，却提供了很多操控文本节点的方法和属性，常用的如下。 1. appendData(text) //在文本末尾追加text内容 2. deleteData(offset,cont) //从offset位置开始删除，删除count个 3. insertData(offset,text) //在offset指定的位置插入text内容 4. replaceData(offset,count,text) //用text替换从offset开始到(offset+count)为止处的文本 5. splitText(offset) //从offset指定的位置将当前文本节点分成两个文本节点 6. substringData(offset,count) //提取从从offset开始到(offset+count)为止处的文本 文本节点的属性：length nodeValue.length或data.length中保存着文本节点中字符的数目。 注意事项：默认情况下每个可以包含内容的元素最多只能有一个文本节点，而且必须确实有内容存在。``` bashecho("----------文本节点操控方法的应用------------");var obj = document.getElementById("div1");var obj2 = document.getElementById("div2");var objh1 = document.getElementById("objh1");//追加新内容obj.childNodes[0].appendData("中华人民共和国");//删除指定内容obj.childNodes[0].deleteData(4,2);//在指定位置插入指定内容obj.childNodes[0].insertData(4,"，insertData");//替换指定文本obj2.childNodes[0].replaceData(10,5,"美国的") ;//获取文本节点长度document.writeln(obj2.childNodes[0].nodeValue.length);//获取子节点长度 echo("---------获取子节点个数------------");document.writeln(obj2.childNodes.length); //输出：1//分割文本节点obj2.childNodes[0].splitText(10) ;document.writeln(obj2.childNodes.length); //输出：2 判断节点类型经常我们需要的是知道一个对象是元素、是属性、还是文本，下一节节点查找我们将看的他的用途。 元素节点的 nodeType值为1 属性节点的nodeType值为2 文本节点的nodeType值为31234var ul = document.getElementById("ul1");echo(ul.nodeType); //输出 1，说明是元素节点echo(ul.childNodes[0].nodeType); //输出 3，说明是文本节点，空白也算echo(ul.childNodes[1].nodeType); //输出 1，说明是元素节点就是第一个li 节点的查找知识点一：父子关系查找 1、hasChildNodes()方法，判断一个对象是否包含子节点。 语法格式：element.hasChildNodes() 返回值：如果对象包含子节点则返回true,如果对象不包含子节点返回false. 2、childNodes 对象，返回一个元素子节点的集合。 3、parentNode属性返回指定节点的父节点。 语法格式：element.parentNode 4、firstChild 指向childNodes中的第一个节点 语法格式：element.firstChild 5、lastChild 指向childNodes列表中的最后一个节点 语法格式：element.lastChild 单词必背： parent：父亲 child：孩子 node：节点 first：第一 last：最后一个123456789101112131415161718192021222324252627282930313233343536var oUl = document.getElementById("oUl");if(oUl.hasChildNodes())&#123; oUlChild = oUl.childNodes; for(var i=0;i&lt;oUlChild.length;i++)&#123; echo(oUlChild[i].nodeName); &#125;&#125;echo("----------------只获取元素节点-------------");var oUl = document.getElementById("oUl");if(oUl.hasChildNodes())&#123; oUlChild = oUl.childNodes; for(var i=0;i&lt;oUlChild.length;i++)&#123; if(oUlChild[i].nodeType==3) continue; echo(oUlChild[i].nodeName); &#125;&#125;echo("----------------批量修改元素节点的样式-------------");var oUl = document.getElementById("oUl");if(oUl.hasChildNodes())&#123; oUlChild = oUl.childNodes; for(var i=0;i&lt;oUlChild.length;i++)&#123; if(oUlChild[i].nodeType==3) continue; oUlChild[i].style.border = "#ff0000 solid 5px"; &#125;&#125;echo("----------------parentNode获取父节点-------------");var oLi = document.getElementById("oLi");echo(oLi.parentNode.tagName); //输出：ULecho(oLi.parentNode.hasChildNodes()); //输出：trueecho(oLi.parentNode.childNodes.length); //输出：7/*提示：parentNode属性可以反复使用，我们可以通过一个元素，找到其父亲，其爷爷(如果有的话) element.parentNode.parentNode 等等*/ 知识点二：兄弟关系查找 1、nextSibling 2、previousSibling1234567891011121314151617181920echo("--------兄弟关系查找--------------");var oH2 = document.getElementById("oH2");var next = oH2.nextSibling.nodeType==1?oH2.nextSibling:null;echo(next) ; //输出null,说明：在IE老版浏览器输出下一个元素，因为对空白文本节点解释不同，现在浏览器认为空白属于文本节点。 为了解决这个问题。一般我们把nexSibling与previousSibling重新封装//封装后的nextSibfunction nextSib(node)&#123; var t = node.parentNode.lastChild; if(node == t)&#123;return null;&#125; //如果是最后一个直接结束函数 var t2 = node.nextSibling; //获取下一个兄弟 //如果下一个兄弟不是元素型的，并且下下一个还有元素 while(t2.nodeType != 1&amp;&amp;t2.nextSibling != null)&#123; t2 = t2.nextSibling; return (t2.nodeType==1?t2 : null); &#125;&#125;var next = nextSib(oH2);echo(next); //[object HTMLPhraseElement]]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript DOM 节点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM模型概念和JavaScript访问和查找节点]]></title>
    <url>%2F2017%2F09%2F18%2FDOM%E8%8A%82%E7%82%B901%2F</url>
    <content type="text"><![CDATA[1：DOM概念 Document,Object,Model文档对象模型，DOM模型给我们动态控制HTML提供了无限自由。 用途：例如不同时间显示不同网页，动态添加、修改，删除HTML元素等。2、节点的概念 一个DOM文档是有很多个小的单元组成的一个大集合，这些小单元我们称为节点。 节点类型3、节点类型 DOM中把节点分为十二种类型常用的有以下几种类型。 3.1、元素节点 3.2、属性节点 3.3、文本节点 3.9、document 3.11、文档片段(fragment)例如：1&lt;a href="http://www.baidu.com" title="百度网站"&gt;连接百度网站&lt;/a&gt; 那么: a标签就是元素节点 href及title就是属性节点 中间的文本[连接百度网站]，就是文本节点。 访问节点4：访问节点 认识节点后，如何控制他们就是dom模型章节的重点，DOM中常用的访问节点的两个方法。 1、getElementById() 2、getElementsByTagName() getElementById(ID)返回指定ID的元素对象，标准的HTML中要求ID必须唯一。 代码示例：123var obj1 = document.getElementById("Dh1");var obj2 = document.getElementById("Dh2");alert(obj1.innerText + obj2.textContent); IE老版本只认： innerText，火狐只认：textContent， 新版本都认：textContent注意：ID号请不要和其他元素的name重名，在IE老浏览器中可能会产生错误。 3.getElementsByTagName(TagName); 功能：获取相同元素名的对象列表到数组中。 代码示例：12var hlist = document.getElementsByTagName("h1");alert(obj1.innerText + obj2.textContent); 用途举例：动态批量修改样式 for(p in hlist){ hlist[p].style.color="#ff0000"; hlist[p].style.border="5px #ff0000 solid"; hlist[p].style.width = "300px"; hlist[p].style.borderRadius = "30px"; } 注意：很多JS代码需要HTML文档加载完毕后才能正确获取对应元素，所以一般都把JS放到最后,或用onload事件判断页面是否加载完毕。]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>javaScript DOM 节点</tag>
      </tags>
  </entry>
</search>
